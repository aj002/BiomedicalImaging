val partial = MeshIO.readMesh(new java.io.File("C:/Users/Home/Desktop/jjn/ step3_data/Femur1.stl")).get
//partial femur mesh val targetGroup = ui.createGroup("target") ui.show(targetGroup, partial,"partial")  val model = StatisticalModelIO.readStatisticalMeshModel(new java.io.File("C:/Users/Home/Desktop/jjn/internship/single_180,50/NewSSMFemur.h5")).get //already developed femur model
val reference = MeshIO.readMesh(new java.io.File("C:/Users/Home/Desktop/jjn/internship/once_again/single_180,50/registered/Mesh0.stl")).get  

val referenceLandmarks = LandmarkIO.readLandmarksJson[_3D](new java.io.File("C:/Users/Home/Desktop/jjn/step3_data/ref_femur10")).get val referencePoints : Seq[Point[_3D]] = referenceLandmarks.map(lm => lm.point) val modelGroup = ui.createGroup("model") ui.show(modelGroup, reference,"reference") val referenceLandmarkViews = referenceLandmarks.map(lm => ui.show(modelGroup, lm, s"lm-${lm.id}"))  val partialLandmarks = LandmarkIO.readLandmarksJson[_3D](new java.io.File("C:/Users/Home/Desktop/jjn/step3_data/target_femur10")).get val partialPoints : Seq[Point[_3D]] = partialLandmarks.map(lm => lm.point) val partialLandmarkViews = partialLandmarks.map(lm => ui.show(targetGroup, lm, s"lm-${lm.id}"))  val domain = UnstructuredPointsDomain(referencePoints.toIndexedSeq) val deformations = (referencePoints.indices).map(i => partialPoints(i) - referencePoints(i) ) val defField = DiscreteField[_3D, UnstructuredPointsDomain[_3D], EuclideanVector[_3D]](domain, deformations) ui.show(modelGroup, defField, "def_Field")   val littleNoise = MultivariateNormalDistribution(DenseVector.zeros[Double](3), DenseMatrix.eye[Double](3) * 0.5)  val regressionData = for ((refPoint, targetPoint) <- referencePoints zip partialPoints) yield {   val refPointId = model.referenceMesh.pointSet.findClosestPoint(refPoint).id   (refPointId, targetPoint, littleNoise) }  val posterior = model.posterior(regressionData.toIndexedSeq)  val posteriorGroup = ui.createGroup("posterior-model") //ui.show(posteriorGroup, posterior, "posterior")  val headPtIDs = model.referenceMesh.pointSet.pointIds.filter { id =>   (model.referenceMesh.pointSet.point(id) - model.referenceMesh.pointSet.point(PointId(15935))).norm <= 80}
//point ID corresponding to the missing point   val posteriorheadModel = posterior.marginal(headPtIDs.toIndexedSeq)  val posteriorheadGroup = ui.createGroup("posterior-nose-model") ui.show(posteriorheadGroup, posteriorheadModel, "posteriorheadModel") val bestReconstruction = posteriorheadModel.mean
val headPtIDs = model.referenceMesh.pointSet.pointIds.filter { id =>   (model.referenceMesh.pointSet.point(id) - model.referenceMesh.pointSet.point(PointId(2000))).norm <= 80
val headPtIDs = model.referenceMesh.pointSet.pointIds.filter { id =>   (model.referenceMesh.pointSet.point(id) - model.referenceMesh.pointSet.point(PointId(17000))).norm <= 120
